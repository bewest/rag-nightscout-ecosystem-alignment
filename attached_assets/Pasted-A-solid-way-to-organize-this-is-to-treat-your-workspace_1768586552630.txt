A solid way to organize this is to treat your workspace repo as (1) a documentation product plus (2) a spec + conformance suite, and make references into upstream code first-class and systematic so you can iterate in cycles without losing track.

Repo layout for docs that reference many codebases

workspace/
  docs/
    00-overview/
    10-domain/
    20-specs/
    30-design/
    40-implementation-notes/
    50-testing/
    60-research/
    90-decisions/           # ADRs
    _includes/              # shared snippets / diagrams / glossary
  specs/
    openapi/
    jsonschema/
    fixtures/
  conformance/
    scenarios/
    assertions/
    runners/
  mapping/
    nightscout/
    aaps/
    trio/
    loop/
  traceability/
    gaps.md
    requirements.md
    coverage-matrix.md
    glossary.md
  tools/
    bootstrap.py
    linkcheck.py
    gen_refs.py
  workspace.lock.json
  externals/                # ignored (bootstrap clones)

What each area is for
	‚Ä¢	docs/: narrative + proposals + how-to‚Äôs. ‚ÄúWhat and why.‚Äù
	‚Ä¢	specs/: normative definitions. ‚ÄúExactly what shape.‚Äù
	‚Ä¢	conformance/: executable truth. ‚ÄúProves it works.‚Äù
	‚Ä¢	mapping/: per-project interpretation notes. ‚ÄúHow project X maps to spec Y.‚Äù
	‚Ä¢	traceability/: coordination control plane. ‚ÄúWhat‚Äôs missing, what‚Äôs covered.‚Äù

This keeps you from mixing ‚Äúdesign debate‚Äù with ‚Äúwhat‚Äôs the actual schema‚Äù with ‚Äúhow Loop implements it.‚Äù

‚∏ª

Make cross-repo code references a named primitive

Instead of pasting code or loose GitHub links, use a consistent reference format you can generate and validate.

Create a ‚Äúcode reference registry‚Äù

docs/_includes/code-refs.md (or a small YAML/JSON registry) with entries like:
	‚Ä¢	repo: nightscout/cgm-remote-monitor
	‚Ä¢	path: lib/server/api3/entries.ts
	‚Ä¢	ref: @lock:cgm-remote-monitor (resolves to SHA in workspace.lock.json)
	‚Ä¢	anchor: L120-L188
	‚Ä¢	purpose: Where devicestatus upload is normalized

Then in docs you write:

See CRM:entries normalization (ref: crm.entries.normalize)

‚Ä¶and tooling can expand that to:
	‚Ä¢	a local path link (externals/...)
	‚Ä¢	an optional GitHub permalink at the pinned SHA
	‚Ä¢	and line numbers if available

Why this matters
	‚Ä¢	Your docs won‚Äôt rot every time upstream changes.
	‚Ä¢	When you cycle back to close gaps, you can update lockfile SHAs and the references stay consistent.

‚∏ª

Use an ‚Äúiterate in cycles‚Äù documentation workflow

The pattern that works is a repeating loop with explicit artifacts:

Cycle outputs (every time)
	1.	Scenario backlog update (what scenario are we addressing?)
	2.	Requirements snippet (what must be true?)
	3.	Spec delta (schema/OpenAPI changes)
	4.	Mapping notes (per project)
	5.	Conformance update (fixtures + assertions)
	6.	Gap/coverage update (traceability)

If you do nothing else, update those six things for each cycle.

Where they live
	‚Ä¢	Scenario: conformance/scenarios/<scenario>/README.md
	‚Ä¢	Requirements: traceability/requirements.md (or one per scenario)
	‚Ä¢	Spec: specs/jsonschema/... and/or specs/openapi/...
	‚Ä¢	Mapping: mapping/<project>/<scenario>.md
	‚Ä¢	Tests: conformance/...
	‚Ä¢	Coverage: traceability/coverage-matrix.md + traceability/gaps.md

That structure makes the project ‚Äúself-correcting‚Äù: every pass tightens the loop.

‚∏ª

Make ‚Äúcoverage gaps‚Äù explicit and measurable

Add a single page that becomes your steering wheel:

traceability/coverage-matrix.md

A table like:
	‚Ä¢	Scenario (row)
	‚Ä¢	Spec sections touched
	‚Ä¢	Nightscout server status
	‚Ä¢	Loop status
	‚Ä¢	AAPS status
	‚Ä¢	Trio status
	‚Ä¢	Notes / blockers

Keep it brutally simple: ‚úÖ / üü° / ‚ùå and a link.

traceability/gaps.md

Not a list of ideas‚Äîonly gaps that block a scenario:
	‚Ä¢	Missing field in schema
	‚Ä¢	Ambiguous semantics (needs ADR)
	‚Ä¢	No known place to extract signal from project X
	‚Ä¢	Test harness missing capability

Agents can help maintain these mechanically.

‚∏ª

Separate ‚Äúnormative‚Äù vs ‚Äúinformative‚Äù docs

You‚Äôll avoid endless argument by labeling content:
	‚Ä¢	Normative (must be true): specs/, conformance/assertions/
	‚Ä¢	Informative (explanations, rationale): docs/, mapping/
	‚Ä¢	Decisions: docs/90-decisions/ (ADRs)

When something is contentious, you write:
	‚Ä¢	ADR explains rationale + tradeoffs
	‚Ä¢	Specs define the actual rule
	‚Ä¢	Conformance enforces it

‚∏ª

Add two lightweight tools early
	1.	Link checker (tools/linkcheck.py)

	‚Ä¢	verifies every code-ref resolves to a file in externals/‚Ä¶
	‚Ä¢	optionally verifies GitHub permalinks at pinned SHAs

	2.	Reference generator (tools/gen_refs.py)

	‚Ä¢	reads workspace.lock.json
	‚Ä¢	emits a docs/_generated/permalinks.json map
	‚Ä¢	lets markdown include stable links without hand editing

This reduces doc maintenance pain dramatically.

‚∏ª

Getting the ball rolling: the first 5 docs to write
	1.	docs/00-overview/mission.md
‚ÄúWhat alignment is, what it is not.‚Äù
	2.	docs/10-domain/glossary.md
Terms: profile, override, desired/observed/delivered, authority, supersede.
	3.	conformance/scenarios/override-supersede/README.md
One flagship scenario with a trace.
	4.	specs/jsonschema/aid-events.schema.json
Minimal schema supporting that scenario.
	5.	traceability/coverage-matrix.md
A single row for the scenario across Nightscout/Loop/AAPS/Trio.

Once those exist, every cycle becomes ‚Äúadd one more scenario and tighten.‚Äù

‚∏ª

If you want, I can draft a concrete starter tree with placeholder markdown files (including templates for Scenario, ADR, Mapping Note, and Requirement) so you can literally copy/paste and start filling content the same day.